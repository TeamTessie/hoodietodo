(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict'

var addOne = require('./helpers/add-one')
var addMany = require('./helpers/add-many')

module.exports = add

/**
 * adds one or multiple objects to local database
 *
 * @param  {Object|Object[]} properties   Properties of one or
 *                                        multiple objects
 * @return {Promise}
 */
function add (objects) {
  return Array.isArray(objects) ?
    addMany.call(this, objects) :
    addOne.call(this, objects)
}

},{"./helpers/add-many":6,"./helpers/add-one":7}],2:[function(require,module,exports){
'use strict'

module.exports = clear

/**
 * destroys db
 */
function clear (state) {
  var db = this

  return db.destroy()
    .then(function () {
      state.emitter.emit('clear')
    })
}

},{}],3:[function(require,module,exports){
'use strict'

var toObject = require('./utils/to-object')
var isntDesignDoc = require('./utils/isnt-design-doc')

module.exports = findAll

/**
 * finds all existing objects in local database.
 *
 * @param  {Function} [filter]   Function returning `true` for any object
 *                               to be returned.
 * @return {Promise}
 */
function findAll (filter) {
  return this.allDocs({
    include_docs: true
  })

  .then(function (res) {
    var objects = res.rows
      .filter(isntDesignDoc)
      .map(function (row) {
        return toObject(row.doc)
      })

    return typeof filter === 'function' ? objects.filter(filter) : objects
  })
}

},{"./utils/isnt-design-doc":29,"./utils/to-object":32}],4:[function(require,module,exports){
'use strict'

var findOrAddOne = require('./helpers/find-or-add-one')
var findOrAddMany = require('./helpers/find-or-add-many')

module.exports = findOrAdd

/**
 * tries to find object in local database, otherwise creates new one
 * with passed properties.
 *
 * @param  {String|Object} idOrObject   id or object with `.id` property
 * @param  {Object}        [properties] Optional properties if id passed
 *                                      as first option
 * @return {Promise}
 */
function findOrAdd (idOrObjectOrArray, newObject) {
  return Array.isArray(idOrObjectOrArray) ?
    findOrAddMany.call(this, idOrObjectOrArray) :
    findOrAddOne.call(this, idOrObjectOrArray, newObject)
}

},{"./helpers/find-or-add-many":11,"./helpers/find-or-add-one":12}],5:[function(require,module,exports){
'use strict'

var findOne = require('./helpers/find-one')
var findMany = require('./helpers/find-many')

module.exports = find

/**
 * finds existing object in local database
 *
 * @param  {String|Object} idOrObject   Id of object or object with
 *                                      `.id` property
 * @return {Promise}
 */
function find (objectsOrIds) {
  return Array.isArray(objectsOrIds) ?
    findMany.call(this, objectsOrIds) :
    findOne.call(this, objectsOrIds)
}

},{"./helpers/find-many":9,"./helpers/find-one":10}],6:[function(require,module,exports){
'use strict'

var toDoc = require('../utils/to-doc')

module.exports = function addMany (objects) {
  var docs = objects.map(toDoc)

  return this.bulkDocs(docs)

  .then(function (responses) {
    return responses.map(function (response, i) {
      if (response instanceof Error) {
        return response
      }

      objects[i].id = response.id
      objects[i]._rev = response.rev
      return objects[i]
    })
  })
}

},{"../utils/to-doc":30}],7:[function(require,module,exports){
'use strict'

var toDoc = require('../utils/to-doc')

module.exports = function addOne (object) {
  var Promise = this.constructor.utils.Promise
  var errors = this.constructor.Errors

  if (typeof object !== 'object') {
    return Promise.reject(errors.NOT_AN_OBJECT)
  }

  var method = object.id ? 'put' : 'post'

  return this[method](toDoc(object))

  .then(function (response) {
    object.id = response.id
    object._rev = response.rev
    return object
  })
}

},{"../utils/to-doc":30}],8:[function(require,module,exports){
module.exports = eventify

/**
 * runs a method from the API and triggers events on each object.
 *
 * Note that we didn't implement this pased on PouchDB's .changes()
 * API on purpose, because of the timeing the events would get triggered.
 * See https://github.com/hoodiehq/pouchdb-hoodie-api/issues/54
 **/
function eventify (db, state, method, eventName) {
  return function () {
    return method.apply(db, arguments).then(function (result) {
      if (Array.isArray(result)) {
        result.forEach(triggerEvent.bind(null, state, eventName))
      } else {
        triggerEvent(state, eventName, result)
      }

      return result
    })
  }
}

function triggerEvent (state, eventName, object) {
  if (!eventName) {
    eventName = parseInt(object._rev, 10) > 1 ? 'update' : 'add'
  }

  state.emitter.emit(eventName, object)
  state.emitter.emit('change', eventName, object)
}

},{}],9:[function(require,module,exports){
'use strict'

var toId = require('../utils/to-id')
var toObject = require('../utils/to-object')

module.exports = function findMany (idsOrObjects) {
  var errors = this.constructor.Errors
  var ids = idsOrObjects.map(toId)

  return this.allDocs({keys: ids, include_docs: true})

  .then(function (response) {
    var foundMap = response.rows.reduce(function (map, row) {
      map[row.id] = row.doc
      return map
    }, {})
    var docs = ids.map(function (id) {
      var doc = foundMap[id]
      if (doc) {
        return doc
      }

      return errors.MISSING_DOC
    })

    return docs.map(toObject)
  })
}

},{"../utils/to-id":31,"../utils/to-object":32}],10:[function(require,module,exports){
'use strict'

var toId = require('../utils/to-id')
var toObject = require('../utils/to-object')

module.exports = function findOne (idOrObject) {
  var id = toId(idOrObject)
  return this.get(id).then(toObject)
}

},{"../utils/to-id":31,"../utils/to-object":32}],11:[function(require,module,exports){
var toId = require('../utils/to-id')
var findMany = require('./find-many')
var addMany = require('./add-many')

module.exports = function findOrAddMany (passedObjects) {
  var self = this
  var foundObjects
  var passedObjectIds = passedObjects.map(toId)

  return findMany.call(this, passedObjectIds)

  .then(function (_foundObjects) {
    foundObjects = _foundObjects

    var foundObjectIds = foundObjects.map(toId)
    var notFoundObjects = passedObjects.reduce(function (notFoundObjects, passedObject) {
      if (foundObjectIds.indexOf(passedObject.id) === -1) {
        notFoundObjects.push(passedObject)
      }
      return notFoundObjects
    }, [])

    return addMany.call(self, notFoundObjects)
  })

  .then(function (addedObjects) {
    var objects = []

    foundObjects.concat(addedObjects).forEach(function (object) {
      var index = passedObjectIds.indexOf(object.id)
      objects[index] = object
    })

    return objects
  })
}

},{"../utils/to-id":31,"./add-many":6,"./find-many":9}],12:[function(require,module,exports){
var toId = require('../utils/to-id')
var findOne = require('./find-one')
var addOne = require('./add-one')

module.exports = function findOrAddOne (idOrObject, newObject) {
  var self = this
  var Promise = this.constructor.utils.Promise
  var errors = this.constructor.Errors
  var id = toId(idOrObject)

  if (!id) {
    return Promise.reject(errors.MISSING_ID)
  }

  if (idOrObject === id && !newObject) {
    return Promise.reject(errors.MISSING_ID)
  }

  return findOne.call(this, id)

  .catch(function (/*error*/) {
    if (typeof newObject === 'object') {
      newObject.id = id
    } else {
      newObject = idOrObject
    }

    return addOne.call(self, newObject)
  })
}

},{"../utils/to-id":31,"./add-one":7,"./find-one":10}],13:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

var changeObject = require('../utils/change-object')
var toDoc = require('../utils/to-doc')
var toId = require('../utils/to-id')
var findMany = require('./find-many')

module.exports = function updateMany (array, change) {
  var self = this
  var errors = this.constructor.Errors
  var objects
  var ids = array.map(toId)

  return findMany.call(this, array)

  .then(function (objects) {
    if (change) {
      return objects.map(function (object) {
        if (object instanceof Error) {
          return object
        }
        return changeObject(change, object)
      })
    }

    return objects.map(function (object, index) {
      var passedObject = array[index]
      if (object instanceof Error) {
        return object
      }
      if (typeof passedObject !== 'object') {
        return errors.NOT_AN_OBJECT
      }
      return extend(object, passedObject)
    })
  })

  .then(function (_objects) {
    objects = _objects
    var validObjects = objects.filter(function (object) {
      return !(object instanceof Error)
    })
    return self.bulkDocs(validObjects.map(toDoc))
  })

  .then(function (responses) {
    responses.forEach(function (response) {
      var index = ids.indexOf(response.id)
      objects[index]._rev = response.rev
    })

    return objects
  })
}

},{"../utils/change-object":28,"../utils/to-doc":30,"../utils/to-id":31,"./find-many":9,"pouchdb-extend":22}],14:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

var changeObject = require('../utils/change-object')
var toDoc = require('../utils/to-doc')
var findOne = require('./find-one')

module.exports = function updateOne (idOrObject, change) {
  var self = this
  var Promise = this.constructor.utils.Promise
  var errors = this.constructor.Errors
  var object

  if (typeof idOrObject === 'string' && !change) {
    return Promise.reject(errors.NOT_AN_OBJECT)
  }

  return findOne.call(this, idOrObject)

  .then(function (object) {
    if (!change) {
      return extend(object, idOrObject)
    }
    return changeObject(change, object)
  })

  .then(function (_object) {
    object = _object
    return self.put(toDoc(object))
  })

  .then(function (response) {
    object._rev = response.rev
    return object
  })
}

},{"../utils/change-object":28,"../utils/to-doc":30,"./find-one":10,"pouchdb-extend":22}],15:[function(require,module,exports){
var toId = require('../utils/to-id')
var addMany = require('./add-many')
var updateMany = require('./update-many')

module.exports = function updateOrAddMany (passedObjects) {
  var self = this
  var addedObjects
  var passedObjectIds = passedObjects.map(toId)

  return addMany.call(this, passedObjects)

  .then(function (_addedObjectsAndErrors) {
    addedObjects = _addedObjectsAndErrors
    var conflicting = passedObjects.reduce(function (array, passedObject, i) {
      var objectOrError = _addedObjectsAndErrors[i]
      var isConflictError = objectOrError instanceof Error && objectOrError.status === 409

      if (isConflictError) {
        array.push(passedObject)
      }
      return array
    }, [])

    return updateMany.call(self, conflicting)
  })

  .then(function (updatedObjects) {
    var objects = []

    updatedObjects.concat(addedObjects).forEach(function (object) {
      var index = passedObjectIds.indexOf(object.id)
      if (index !== -1) {
        objects[index] = object
      }
    })

    return objects
  })
}

},{"../utils/to-id":31,"./add-many":6,"./update-many":13}],16:[function(require,module,exports){
var toId = require('../utils/to-id')
var addOne = require('./add-one')
var updateOne = require('./update-one')

module.exports = function updateOrAddOne (idOrObject, newObject) {
  var self = this
  return updateOne.call(this, idOrObject, newObject)

  .catch(function (error) {
    if (error.status !== 404) {
      throw error
    }

    if (newObject) {
      newObject.id = toId(idOrObject)
      return addOne.call(self, newObject)
    }

    return addOne.call(self, idOrObject)
  })
}

},{"../utils/to-id":31,"./add-one":7,"./update-one":14}],17:[function(require,module,exports){
'use strict'

var exports = module.exports = { hoodieApi: hoodieApi }

var EventEmitter = require('events').EventEmitter

var eventify = require('./helpers/eventify')

function hoodieApi (options) {
  var state = {
    emitter: options && options.emitter || new EventEmitter()
  }

  return {
    db: this,
    add: eventify(this, state, require('./add')),
    find: require('./find').bind(this),
    findAll: require('./find-all').bind(this),
    findOrAdd: eventify(this, state, require('./find-or-add')),
    update: eventify(this, state, require('./update')),
    updateOrAdd: eventify(this, state, require('./update-or-add')),
    updateAll: eventify(this, state, require('./update-all')),
    remove: eventify(this, state, require('./remove'), 'remove'),
    removeAll: eventify(this, state, require('./remove-all'), 'remove'),
    on: require('./lib/on').bind(this, state),
    one: require('./lib/one').bind(this, state),
    off: require('./lib/off').bind(this, state),
    clear: require('./clear').bind(this, state)
  }
}

/* istanbul ignore next */
if (typeof window !== 'undefined' && window.PouchDB) {
  window.PouchDB.plugin(exports)
}

},{"./add":1,"./clear":2,"./find":5,"./find-all":3,"./find-or-add":4,"./helpers/eventify":8,"./lib/off":18,"./lib/on":19,"./lib/one":20,"./remove":24,"./remove-all":23,"./update":27,"./update-all":25,"./update-or-add":26,"events":21}],18:[function(require,module,exports){
'use strict'

module.exports = off

/**
 * removes a listener for the specified event
 *
 * It will unsubscribe at most, one instance of a listener for a particular event.
 * If any single listener has subcribed multiple times to the same event,
 * then `off` must be called multiple times.
 *
 * Supported events:
 *
 * - `add`
 * - `update`
 * - `remove`
 * - `change`
 *
 * @param  {String} eventName
 *         Name of event, one of listed above
 * @param  {Function} handler
 *         callback for event
 */
function off (state, eventName, handler) {
  state.emitter.removeListener(eventName, handler)

  return this
}

},{}],19:[function(require,module,exports){
'use strict'

module.exports = on

/**
 * add a listener to an event
 *
 * Supported events:
 *
 * - `add`    → (object, options)
 * - `update` → (object, options)
 * - `remove` → (object, options)
 * - `change` → (eventName, object, options)
 *
 * @param  {String} eventName
 *         Name of event, one of listed above
 * @param  {Function} handler
 *         callback for event
 */
function on (state, eventName, handler) {
  state.emitter.on(eventName, handler)

  return this
}

},{}],20:[function(require,module,exports){
'use strict'

module.exports = one

/**
 * adds a one time listener to an event
 *
 * Supported events:
 *
 * - `add`    → (object, options)
 * - `update` → (object, options)
 * - `remove` → (object, options)
 * - `change` → (eventName, object, options)
 *
 * @param  {String} eventName
 *         Name of event, one of listed above
 * @param  {Function} handler
 *         callback for event
 */
function one (state, eventName, handler) {
  state.emitter.once(eventName, handler)

  return this
}

},{}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],22:[function(require,module,exports){
"use strict";

// Extends method
// (taken from http://code.jquery.com/jquery-1.9.0.js)
// Populate the class2type map
var class2type = {};

var types = [
  "Boolean", "Number", "String", "Function", "Array",
  "Date", "RegExp", "Object", "Error"
];
for (var i = 0; i < types.length; i++) {
  var typename = types[i];
  class2type["[object " + typename + "]"] = typename.toLowerCase();
}

var core_toString = class2type.toString;
var core_hasOwn = class2type.hasOwnProperty;

function type(obj) {
  if (obj === null) {
    return String(obj);
  }
  return typeof obj === "object" || typeof obj === "function" ?
    class2type[core_toString.call(obj)] || "object" :
    typeof obj;
}

function isWindow(obj) {
  return obj !== null && obj === obj.window;
}

function isPlainObject(obj) {
  // Must be an Object.
  // Because of IE, we also have to check the presence of
  // the constructor property.
  // Make sure that DOM nodes and window objects don't pass through, as well
  if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
    return false;
  }

  try {
    // Not own constructor property must be Object
    if (obj.constructor &&
      !core_hasOwn.call(obj, "constructor") &&
      !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
      return false;
    }
  } catch ( e ) {
    // IE8,9 Will throw exceptions on certain host objects #9897
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) {}

  return key === undefined || core_hasOwn.call(obj, key);
}


function isFunction(obj) {
  return type(obj) === "function";
}

var isArray = Array.isArray || function (obj) {
  return type(obj) === "array";
};

function extend() {
  // originally extend() was recursive, but this ended up giving us
  // "call stack exceeded", so it's been unrolled to use a literal stack
  // (see https://github.com/pouchdb/pouchdb/issues/2543)
  var stack = [];
  var i = -1;
  var len = arguments.length;
  var args = new Array(len);
  while (++i < len) {
    args[i] = arguments[i];
  }
  var container = {};
  stack.push({args: args, result: {container: container, key: 'key'}});
  var next;
  while ((next = stack.pop())) {
    extendInner(stack, next.args, next.result);
  }
  return container.key;
}

function extendInner(stack, args, result) {
  var options, name, src, copy, copyIsArray, clone,
    target = args[0] || {},
    i = 1,
    length = args.length,
    deep = false,
    numericStringRegex = /\d+/,
    optionsIsArray;

  // Handle a deep copy situation
  if (typeof target === "boolean") {
    deep = target;
    target = args[1] || {};
    // skip the boolean and the target
    i = 2;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if (typeof target !== "object" && !isFunction(target)) {
    target = {};
  }

  // extend jQuery itself if only one argument is passed
  if (length === i) {
    /* jshint validthis: true */
    target = this;
    --i;
  }

  for (; i < length; i++) {
    // Only deal with non-null/undefined values
    if ((options = args[i]) != null) {
      optionsIsArray = isArray(options);
      // Extend the base object
      for (name in options) {
        //if (options.hasOwnProperty(name)) {
        if (!(name in Object.prototype)) {
          if (optionsIsArray && !numericStringRegex.test(name)) {
            continue;
          }

          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (isPlainObject(copy) ||
              (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];

            } else {
              clone = src && isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            stack.push({
              args: [deep, clone, copy],
              result: {
                container: target,
                key: name
              }
            });

          // Don't bring in undefined values
          } else if (copy !== undefined) {
            if (!(isArray(options) && isFunction(copy))) {
              target[name] = copy;
            }
          }
        }
      }
    }
  }

  // "Return" the modified object by setting the key
  // on the given container
  result.container[result.key] = target;
}


module.exports = extend;



},{}],23:[function(require,module,exports){
'use strict'

var toObject = require('./utils/to-object')
var toDoc = require('./utils/to-doc')
var isntDesignDoc = require('./utils/isnt-design-doc')

module.exports = removeAll

/**
 * removes all existing objects
 *
 * @param  {Function} [filter]   Function returning `true` for any object
 *                               to be removed.
 * @return {Promise}
 */
function removeAll (filter) {
  var objects

  return this.allDocs({
    include_docs: true
  })

  .then(function (res) {
    objects = res.rows
      .filter(isntDesignDoc)
      .map(function (row) {
        return toObject(row.doc)
      })

    if (typeof filter === 'function') {
      objects = objects.filter(filter)
    }

    return objects.map(function (object) {
      var doc = toDoc(object)
      doc._deleted = true
      return doc
    })
  })

  .then(this.bulkDocs.bind(this))

  .then(function (results) {
    return results.map(function (result, i) {
      objects[i]._rev = result.rev
      return objects[i]
    })
  })
}

},{"./utils/isnt-design-doc":29,"./utils/to-doc":30,"./utils/to-object":32}],24:[function(require,module,exports){
'use strict'

var updateOne = require('./helpers/update-one')
var updateMany = require('./helpers/update-many')

module.exports = remove

/**
 * removes existing object
 *
 * @param  {Object|Function} change   changed properties or function that
 *                                    alters passed object
 * @return {Promise}
 */
function remove (objectsOrIds) {
  return Array.isArray(objectsOrIds) ?
    updateMany.call(this, objectsOrIds, {_deleted: true}) :
    updateOne.call(this, objectsOrIds, {_deleted: true})
}

},{"./helpers/update-many":13,"./helpers/update-one":14}],25:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

var toObject = require('./utils/to-object')
var toDoc = require('./utils/to-doc')
var isntDesignDoc = require('./utils/isnt-design-doc')

module.exports = updateAll

/**
 * updates all existing objects
 *
 * @param  {Object|Function} change   changed properties or function that
 *                                    alters passed object
 * @return {Promise}
 */
function updateAll (changedProperties) {
  var Promise = this.constructor.utils.Promise

  var type = typeof changedProperties
  var objects

  if (type !== 'object' && type !== 'function') {
    return Promise.reject(new Error('Must provide object or function'))
  }

  return this.allDocs({
    include_docs: true
  })

  .then(function (res) {
    objects = res.rows
      .filter(isntDesignDoc)
      .map(function (row) {
        return toObject(row.doc)
      })

    if (type === 'function') {
      objects.forEach(changedProperties)
      return objects.map(toDoc)
    }

    return objects.map(function (object) {
      extend(object, changedProperties)
      return toDoc(object)
    })
  })

  .then(function (result) {
    return result
  })
  .then(this.bulkDocs.bind(this))

  .then(function (results) {
    return results.map(function (result, i) {
      objects[i]._rev = result.rev
      return objects[i]
    })
  })
}

},{"./utils/isnt-design-doc":29,"./utils/to-doc":30,"./utils/to-object":32,"pouchdb-extend":22}],26:[function(require,module,exports){
'use strict'

var updateOrAddOne = require('./helpers/update-or-add-one')
var updateOrAddMany = require('./helpers/update-or-add-many')

module.exports = updateOrAdd

/**
 * updates existing object, or creates otherwise.
 *
 * @param  {String|Object|Object[]} - id or object with `.id` property, or
 *                                    array of properties
 * @param  {Object} [properties]      If id passed, properties for new
 *                                    or existing object
 * @return {Promise}
 */
function updateOrAdd (idOrObjectOrArray, newObject) {
  return Array.isArray(idOrObjectOrArray) ?
    updateOrAddMany.call(this, idOrObjectOrArray) :
    updateOrAddOne.call(this, idOrObjectOrArray, newObject)
}

},{"./helpers/update-or-add-many":15,"./helpers/update-or-add-one":16}],27:[function(require,module,exports){
'use strict'

var updateOne = require('./helpers/update-one')
var updateMany = require('./helpers/update-many')

module.exports = update

/**
 * updates existing object.
 *
 * @param  {String|Object}   idOrObject   id or object with `.id` property
 * @param  {Object|Function} [change]     Changed properties or function
 *                                        that changes existing object
 * @return {Promise}
 */
function update (objectsOrIds, change) {
  if (typeof objectsOrIds !== 'object' && !change) {
    return this.constructor.utils.Promise.reject(
      new Error('Must provide change')
    )
  }

  return Array.isArray(objectsOrIds) ?
    updateMany.call(this, objectsOrIds, change) :
    updateOne.call(this, objectsOrIds, change)
}

},{"./helpers/update-many":13,"./helpers/update-one":14}],28:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

/**
  * change object either by passing changed properties
  * as an object, or by passing a change function that
  * manipulates the passed object directly
  **/
module.exports = function changeObject (change, object) {
  if (typeof change === 'object') {
    return extend(object, change)
  }

  change(object)
  return object
}

},{"pouchdb-extend":22}],29:[function(require,module,exports){
'use strict'

// Checks for a design doc, so we can filters out docs that shouldn't return in *All methods
module.exports = function isntDesignDoc (row) {
  return row.id.match(/^_design/) === null
}

},{}],30:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

module.exports = function objectToDoc (object) {
  var doc = extend({}, object, {
    _id: object.id
  })

  delete doc.id
  return doc
}

},{"pouchdb-extend":22}],31:[function(require,module,exports){
'use strict'

module.exports = function objectOrIdToId (objectOrId) {
  return typeof objectOrId === 'object' ? objectOrId.id : objectOrId
}

},{}],32:[function(require,module,exports){
'use strict'

var extend = require('pouchdb-extend')

module.exports = function docToObject (doc) {
  if (doc instanceof Error) {
    return doc
  }

  var object = extend({}, doc, {
    id: doc._id
  })

  delete object._id
  return object
}

},{"pouchdb-extend":22}]},{},[17]);
